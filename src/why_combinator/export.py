"""Export module: PDF, Markdown, JSON, CSV, webhooks, pipe-friendly output."""
import json
import csv
import io
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional
from why_combinator.models import SimulationEntity, InteractionLog, MetricSnapshot
from why_combinator.storage import StorageManager

logger = logging.getLogger(__name__)

def export_json_report(storage: StorageManager, simulation_id: str, output_path: Path):
    """Export simulation data as JSON."""
    sim = storage.get_simulation(simulation_id)
    if not sim:
        return
    data = {
        "simulation": sim.to_dict(),
        "agents": [a.to_dict() for a in storage.get_agents(simulation_id)],
        "interactions": [i.to_dict() for i in storage.get_interactions(simulation_id)],
        "metrics": [m.to_dict() for m in storage.get_metrics(simulation_id)],
    }
    output_path.write_text(json.dumps(data, indent=2, default=str))
    logger.info(f"JSON export: {output_path}")

def export_csv_report(storage: StorageManager, simulation_id: str, output_path: Path):
    """Export interactions as CSV."""
    interactions = storage.get_interactions(simulation_id)
    with open(output_path, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["id", "agent_id", "simulation_id", "timestamp", "action", "target", "outcome"])
        for i in interactions:
            writer.writerow([i.id, i.agent_id, i.simulation_id, i.timestamp, i.action, i.target, json.dumps(i.outcome)])
    logger.info(f"CSV export: {output_path}")

def export_markdown_report(storage: StorageManager, simulation_id: str, output_path: Path, metrics: Dict[str, float] = None):
    """Export simulation as Markdown report."""
    sim = storage.get_simulation(simulation_id)
    if not sim:
        return
    agents = storage.get_agents(simulation_id)
    interactions = storage.get_interactions(simulation_id)
    metrics_data = storage.get_metrics(simulation_id)
    latest_metrics = metrics or {}
    if not latest_metrics and metrics_data:
        for m in metrics_data:
            latest_metrics[m.metric_type] = m.value
    lines = [
        f"# {sim.name} - Simulation Report\n",
        f"**Industry:** {sim.industry}  ",
        f"**Stage:** {sim.stage.value}  ",
        f"**Description:** {sim.description}\n",
        "## Agents\n",
        "| Name | Role | Type |",
        "|------|------|------|",
    ]
    for a in agents:
        lines.append(f"| {a.name} | {a.role} | {a.type.value} |")
    lines.append("\n## Metrics\n")
    for k, v in latest_metrics.items():
        lines.append(f"- **{k}:** {v:.4f}")
    lines.append(f"\n## Interactions ({len(interactions)} total)\n")
    from collections import Counter
    action_counts = Counter(i.action for i in interactions)
    for action, count in action_counts.most_common(10):
        lines.append(f"- {action}: {count}")
    lines.append("\n---\n*Generated by Why-Combinator*\n")
    output_path.write_text("\n".join(lines))
    logger.info(f"Markdown export: {output_path}")

def export_pdf_report(storage: StorageManager, simulation_id: str, output_path: Path, metrics: Dict[str, float] = None):
    """Export as PDF (requires fpdf2). Falls back to text if not available."""
    try:
        from fpdf import FPDF
    except ImportError:
        txt_path = output_path.with_suffix(".txt")
        export_markdown_report(storage, simulation_id, txt_path, metrics)
        logger.warning(f"fpdf2 not installed. Exported as text instead: {txt_path}")
        return
    sim = storage.get_simulation(simulation_id)
    if not sim:
        return
    agents = storage.get_agents(simulation_id)
    interactions = storage.get_interactions(simulation_id)
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", "B", 16)
    pdf.cell(0, 10, f"{sim.name} - Simulation Report", new_x="LMARGIN", new_y="NEXT")
    pdf.set_font("Helvetica", "", 10)
    pdf.cell(0, 6, f"Industry: {sim.industry} | Stage: {sim.stage.value}", new_x="LMARGIN", new_y="NEXT")
    pdf.cell(0, 6, f"Description: {sim.description}", new_x="LMARGIN", new_y="NEXT")
    pdf.ln(5)
    pdf.set_font("Helvetica", "B", 12)
    pdf.cell(0, 8, "Agents", new_x="LMARGIN", new_y="NEXT")
    pdf.set_font("Helvetica", "", 9)
    for a in agents:
        pdf.cell(0, 5, f"  {a.name} - {a.role} ({a.type.value})", new_x="LMARGIN", new_y="NEXT")
    pdf.ln(3)
    pdf.set_font("Helvetica", "B", 12)
    pdf.cell(0, 8, f"Interactions ({len(interactions)} total)", new_x="LMARGIN", new_y="NEXT")
    pdf.set_font("Helvetica", "", 9)
    from collections import Counter
    for action, count in Counter(i.action for i in interactions).most_common(10):
        pdf.cell(0, 5, f"  {action}: {count}", new_x="LMARGIN", new_y="NEXT")
    if metrics:
        pdf.ln(3)
        pdf.set_font("Helvetica", "B", 12)
        pdf.cell(0, 8, "Metrics", new_x="LMARGIN", new_y="NEXT")
        pdf.set_font("Helvetica", "", 9)
        for k, v in metrics.items():
            pdf.cell(0, 5, f"  {k}: {v:.4f}", new_x="LMARGIN", new_y="NEXT")
    pdf.output(str(output_path))
    logger.info(f"PDF export: {output_path}")

def send_webhook(url: str, payload: Dict[str, Any]):
    """Send webhook notification to Slack/Discord."""
    try:
        import httpx
        response = httpx.post(url, json=payload, timeout=10.0)
        response.raise_for_status()
        logger.info(f"Webhook sent to {url}")
    except Exception as e:
        logger.error(f"Webhook failed: {e}")

def pipe_friendly_output(data: Dict[str, Any]) -> str:
    """Output JSON for piping to other tools."""
    return json.dumps(data, default=str)
